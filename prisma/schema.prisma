generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                     String         @id @unique
  email                  String         @unique
  name                   String?
  stripeCustomerId       String?        @unique
  monthlyDatasetsLimit   Int            @default(1)
  currentDatasetsUsage   Int            @default(0)
  monthlyAIInsightsLimit Int            @default(3)
  currentAIInsightsUsage Int            @default(0)
  dailyDataPointsLimit   Int            @default(100)
  currentDataPointsUsage Int            @default(0)
  lastAIReset            DateTime       @default(now())
  lastDataPointsReset    DateTime       @default(now())
  timezone               String         @default("Europe/Madrid")
  notificationsEmail     Boolean        @default(true)
  notificationsSlack     Boolean        @default(false)
  slackWebhookUrl        String?
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  activityLogs           ActivityLog[]
  apiKeys                ApiKey[]
  datasets               Dataset[]
  insights               Insight[]
  notifications          Notification[]
  subscription           Subscription?

  @@index([email])
}

model Subscription {
  stripeSubscriptionId String   @id @unique
  status               String
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  interval             String
  planId               String
  cancelAtPeriodEnd    Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  userId               String   @unique
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model Dataset {
  id               String      @id @default(cuid())
  userId           String
  name             String
  description      String?
  status           String      @default("active")
  source           String
  mqttBroker       String?
  mqttTopic        String?
  mqttUsername     String?
  mqttPassword     String?
  webhookUrl       String?     @unique
  webhookSecret    String?
  apiEndpoint      String?
  boundingBox      Json?
  totalDataPoints  Int         @default(0)
  dataPointsToday  Int         @default(0)
  lastDataReceived DateTime?
  avgUpdateFreq    Int?
  alertsEnabled    Boolean     @default(false)
  alertThresholds  Json?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
  maxDataPoints    Int         @default(100)
  alerts           Alert[]
  dataPoints       DataPoint[]
  user             User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  insights         Insight[]
  layers           Layer[]
  mapping          DatasetMapping?

  @@index([userId, status])
  @@index([userId, createdAt])
}

model DatasetMapping {
  id        String   @id @default(cuid())
  datasetId String   @unique
  
  // Paths para mapear campos del payload MQTT
  valuePath      String   @default("value")
  xPath          String?  @default("x")
  yPath          String?  @default("y")
  zPath          String?  @default("z")
  sensorIdPath   String?  @default("sensorId")
  sensorTypePath String?  @default("sensorType")
  timestampPath  String   @default("timestamp")
  unitPath       String?  @default("unit")
  
  // Metadata adicional
  metadata  Json?
  
  // Configuración de transformaciones
  transforms Json?  // Para futuras transformaciones (ej: escalado, conversión de unidades)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  dataset   Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  
  @@index([datasetId])
}

model SensorConfig {
  id        String   @id @default(cuid())
  datasetId String
  sensorId  String
  name      String?
  type      String?
  unit      String?
  location  Json?
  metadata  Json?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([datasetId, sensorId])
  @@index([datasetId])
}

model DataPoint {
  id             String   @id @default(cuid())
  datasetId      String
  value          Float
  sensorId       String
  metadata       Json?
  timestamp      DateTime @default(now())
  createdAt      DateTime @default(now())
  isLatest       Boolean  @default(true)
  sensorConfigId String?
  dataset        Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId, timestamp(sort: Desc)])
  @@index([sensorId, timestamp(sort: Desc)])
}

model Layer {
  id          String   @id @default(cuid())
  datasetId   String
  name        String
  description String?
  enabled     Boolean  @default(true)
  order       Int      @default(0)
  colorScheme Json?
  opacity     Float    @default(1.0)
  pointSize   Float    @default(1.0)
  filterQuery String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  dataset     Dataset  @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId, order])
}

model Alert {
  id             String    @id @default(cuid())
  datasetId      String
  name           String
  condition      String
  thresholdValue Float
  currentValue   Float
  status         String    @default("active")
  severity       String
  message        String
  triggeredAt    DateTime  @default(now())
  acknowledgedAt DateTime?
  acknowledgedBy String?
  resolvedAt     DateTime?
  mutedUntil     DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  dataset        Dataset   @relation(fields: [datasetId], references: [id], onDelete: Cascade)

  @@index([datasetId, status])
  @@index([status, severity])
}

model Insight {
  id               String    @id @default(cuid())
  userId           String
  datasetId        String
  type             String
  severity         String
  title            String
  summary          String
  details          String?
  recommendations  String?
  affectedArea     Json?
  metricsDelta     Json?
  isResolved       Boolean   @default(false)
  resolvedAt       DateTime?
  resolvedBy       String?
  modelUsed        String?   @default("gemini-2.0-flash-exp")
  confidence       Float?
  processingTimeMs Int?
  tokensUsed       Int?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  dataset          Dataset   @relation(fields: [datasetId], references: [id], onDelete: Cascade)
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([datasetId, severity])
}

model Notification {
  id          String    @id @default(cuid())
  userId      String
  type        String    @default("info")
  title       String
  message     String
  isRead      Boolean   @default(false)
  readAt      DateTime?
  relatedType String?
  relatedId   String?
  actionUrl   String?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
}

model ApiKey {
  id         String    @id @default(cuid())
  userId     String
  name       String
  key        String    @unique
  prefix     String
  isActive   Boolean   @default(true)
  lastUsedAt DateTime?
  expiresAt  DateTime?
  rateLimit  Int       @default(1000)
  usageCount Int       @default(0)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive])
}

model ActivityLog {
  id         String   @id @default(cuid())
  userId     String?
  action     String
  resource   String
  resourceId String?
  metadata   Json?
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())
  user       User?    @relation(fields: [userId], references: [id])

  @@index([userId, createdAt(sort: Desc)])
  @@index([action, createdAt(sort: Desc)])
}
